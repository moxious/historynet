---
title: React Hooks Rules
description: Critical React hooks patterns - cleanup, closures, dependencies, conditional calls.
globs:
  - "**/hooks/**"
  - "**/*.tsx"
---

# React Hooks Rules

Rules for proper hook usage. Check these when working with `useEffect`, `useState`, `useRef`, and custom hooks.

---

## R1 — Missing useEffect Cleanup

Subscriptions, event listeners, and timers created in `useEffect` must be cleaned up to prevent memory leaks.

**Don't**
```tsx
useEffect(() => {
  const subscription = dataSource.subscribe(handleData);
  window.addEventListener('resize', handleResize);
  const timer = setInterval(pollData, 5000);
  // No cleanup - resources persist after unmount
}, []);
```

**Do**
```tsx
useEffect(() => {
  const subscription = dataSource.subscribe(handleData);
  window.addEventListener('resize', handleResize);
  const timer = setInterval(pollData, 5000);

  // REACT: cleanup subscriptions, listeners, timers (R1)
  return () => {
    subscription.unsubscribe();
    window.removeEventListener('resize', handleResize);
    clearInterval(timer);
  };
}, []);
```

**Agent behavior**
- Flag any `useEffect` with `addEventListener`, `subscribe`, `setInterval`, or `setTimeout` that lacks a cleanup return.
- Ensure WebSocket connections, MutationObservers, and ResizeObservers are disconnected on cleanup.

---

## R2 — Stale Closure in Callbacks

Closures in `useEffect` or callbacks capture variable values at creation time. Without proper handling, they reference stale data.

**Don't**
```tsx
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    setCount(count + 1); // Always reads initial count (0)
  }, 1000);
  return () => clearInterval(timer);
}, []); // count not in deps - stale closure
```

**Do**
```tsx
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    // REACT: functional update avoids stale closure (R2)
    setCount(prev => prev + 1);
  }, 1000);
  return () => clearInterval(timer);
}, []);
```

**Agent behavior**
- When state is used inside `setInterval`, `setTimeout`, or event callbacks, prefer functional updates (`setState(prev => ...)`).
- If a callback needs the latest value but can't use functional updates, use a ref to track current state.

---

## R4 — State Update on Unmounted Component

Async operations may complete after component unmounts. Attempting to `setState` on unmounted components causes memory leaks.

**Don't**
```tsx
useEffect(() => {
  fetch(\`/api/users/\${userId}\`)
    .then(res => res.json())
    .then(setData); // May run after unmount
}, [userId]);
```

**Do**
```tsx
useEffect(() => {
  const controller = new AbortController();
  
  fetch(\`/api/users/\${userId}\`, { signal: controller.signal })
    .then(res => res.json())
    .then(setData)
    .catch(err => {
      // REACT: ignore abort errors (R4)
      if (err.name !== 'AbortError') throw err;
    });
  
  return () => controller.abort();
}, [userId]);
```

**Agent behavior**
- For any `fetch` or async operation in `useEffect`, require either `AbortController` or a mounted flag.
- Prefer `AbortController` as it actually cancels the network request.

---

## R7 — Race Condition in Async State Updates

Network requests don't complete in order. Earlier requests may resolve after later ones, showing stale data.

**Don't**
```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    fetchResults(query).then(setResults);
    // User types "re" -> "rea" -> "react"
    // Responses may arrive out of order
  }, [query]);
}
```

**Do**
```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    let cancelled = false;
    
    fetchResults(query).then(data => {
      // REACT: ignore stale responses (R7)
      if (!cancelled) setResults(data);
    });
    
    return () => { cancelled = true; };
  }, [query]);
}
```

**Agent behavior**
- For any search/filter/autocomplete pattern, require race condition handling.
- Prefer `AbortController` over boolean flags when possible.

---

## R8 — Conditional Hook Calls

React tracks hooks by call order. Conditional hooks break this tracking.

**Don't**
```tsx
function UserDashboard({ user }) {
  if (!user) {
    return <LoginPrompt />;
  }
  
  // These hooks only run sometimes - violates rules
  const [data, setData] = useState(null);
  const theme = useContext(ThemeContext);
}
```

**Do**
```tsx
function UserDashboard({ user }) {
  // REACT: all hooks at top level, always called (R8)
  const [data, setData] = useState(null);
  const theme = useContext(ThemeContext);
  
  // Conditional rendering AFTER all hooks
  if (!user) {
    return <LoginPrompt />;
  }
  
  return <Dashboard data={data} theme={theme} />;
}
```

**Agent behavior**
- Flag any hook call that appears after a conditional return statement.
- Flag hooks inside `if` blocks, loops, or nested functions.
- Ensure all hooks are called unconditionally at the top of the component.

---

## R13 — Missing Dependency Array in useEffect

Without a dependency array, `useEffect` runs after every render, potentially causing infinite loops.

**Don't**
```tsx
useEffect(() => {
  fetchUserData(userId).then(setData);
}); // Missing [] - runs EVERY render
```

**Do**
```tsx
// REACT: explicit dependencies (R13)
useEffect(() => {
  fetchUserData(userId).then(setData);
}, [userId]); // Runs when userId changes

// For one-time setup:
useEffect(() => {
  initializeApp();
}, []); // Empty array = mount only
```

**Agent behavior**
- Every `useEffect` MUST have a dependency array (even if empty).
- Flag any `useEffect` without a second argument.

---

## R15 — Ref Manipulation Without Cleanup

DOM refs can accumulate event listeners and external library instances if not cleaned up.

**Don't**
```tsx
function VideoPlayer({ src }) {
  const videoRef = useRef();
  
  useEffect(() => {
    const video = videoRef.current;
    video.addEventListener('ended', handleEnded);
    
    const player = new FancyPlayer(video);
    player.init();
    // No cleanup - listeners accumulate
  }, []);
}
```

**Do**
```tsx
function VideoPlayer({ src }) {
  const videoRef = useRef();
  const playerRef = useRef();
  
  useEffect(() => {
    const video = videoRef.current;
    video.addEventListener('ended', handleEnded);
    
    playerRef.current = new FancyPlayer(video);
    playerRef.current.init();
    
    // REACT: clean up DOM listeners and external libraries (R15)
    return () => {
      video.removeEventListener('ended', handleEnded);
      playerRef.current?.destroy();
    };
  }, []);
}
```

**Agent behavior**
- Any `addEventListener` on a ref element requires `removeEventListener` in cleanup.
- External libraries attached to DOM elements must be destroyed/disposed on cleanup.

---

## Quick Detection Checklist

| Pattern | Rule | Action |
|---------|------|--------|
| `useEffect` without cleanup return | R1 | Add cleanup |
| State in callback without functional update | R2 | Use `prev =>` |
| `fetch` without `AbortController` | R4 | Add abort handling |
| Search effect without cancellation | R7 | Add cancelled flag |
| Hook after conditional return | R8 | Move hooks to top |
| `useEffect` without dependency array | R13 | Add `[]` or deps |
| DOM listener without cleanup | R15 | Add `removeEventListener` |
