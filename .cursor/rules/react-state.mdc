---
title: React State Management Rules
description: State mutation, context patterns, and derived state rules.
globs:
  - "**/contexts/**"
  - "**/hooks/use*State*"
  - "**/*.tsx"
---

# React State Management Rules

Rules for proper state handling. Check these when working with `useState`, Context, and derived values.

---

## R5 — Direct State Mutation

React uses reference equality to detect changes. Mutating objects/arrays in place prevents re-renders.

**Don't**
```tsx
const [todos, setTodos] = useState([{ id: 1, text: 'Learn React' }]);

const updateTodo = (id, newText) => {
  const todo = todos.find(t => t.id === id);
  todo.text = newText; // Mutation!
  setTodos(todos); // Same reference - no re-render
};

const addTodo = (text) => {
  todos.push({ id: Date.now(), text }); // Mutation!
  setTodos(todos);
};
```

**Do**
```tsx
const updateTodo = (id, newText) => {
  // REACT: immutable update (R5)
  setTodos(todos.map(todo => 
    todo.id === id ? { ...todo, text: newText } : todo
  ));
};

const addTodo = (text) => {
  // REACT: spread to create new array (R5)
  setTodos([...todos, { id: Date.now(), text }]);
};

// For deeply nested state, consider Immer:
import { produce } from 'immer';
setTodos(produce(todos, draft => {
  const todo = draft.find(t => t.id === id);
  todo.text = newText;
}));
```

**Agent behavior**
- Flag any direct property assignment on state objects (`state.prop = value`).
- Flag `.push()`, `.pop()`, `.splice()`, `.sort()` on state arrays without spread.
- Recommend spread operators or `map`/`filter` for immutable updates.
- For complex nested updates, suggest Immer if not already in use.

---

## R11 — Context Overuse for Frequent Updates

Context re-renders ALL consuming components when its value changes.

**Don't**
```tsx
const AppContext = createContext();

function App() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handler = (e) => setMousePosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handler);
    return () => window.removeEventListener('mousemove', handler);
  }, []);
  
  // Every mouse move re-renders ALL consumers
  return (
    <AppContext.Provider value={{ mousePosition, user, theme }}>
      <EntireApp />
    </AppContext.Provider>
  );
}
```

**Do**
```tsx
// REACT: separate contexts by update frequency (R11)
const MouseContext = createContext();
const UserContext = createContext();
const ThemeContext = createContext();

function App() {
  const mousePosition = useMousePosition(); // Custom hook
  
  // Memoize context value to prevent object reference changes
  const mouseValue = useMemo(() => mousePosition, [mousePosition.x, mousePosition.y]);
  
  return (
    <ThemeContext.Provider value={theme}>
      <UserContext.Provider value={user}>
        <MouseContext.Provider value={mouseValue}>
          <EntireApp />
        </MouseContext.Provider>
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}
```

**Agent behavior**
- Flag context providers with frequently-changing values (mouse position, timers, input values).
- Recommend splitting contexts by update frequency.
- Ensure context values are memoized to prevent unnecessary reference changes.
- For high-frequency updates, suggest state management libraries or component-local state.

---

## R14 — Derived State Anti-Pattern

Storing computed values in state creates synchronization bugs and unnecessary renders.

**Don't**
```tsx
function FilteredList({ items, filter }) {
  // Storing derived data in state - must manually sync
  const [filteredItems, setFilteredItems] = useState(
    items.filter(i => i.category === filter)
  );
  
  useEffect(() => {
    setFilteredItems(items.filter(i => i.category === filter));
  }, [items, filter]); // Extra render to sync
  
  return <List items={filteredItems} />;
}
```

**Do**
```tsx
function FilteredList({ items, filter }) {
  // REACT: compute during render - always in sync (R14)
  const filteredItems = useMemo(
    () => items.filter(i => i.category === filter),
    [items, filter]
  );
  
  return <List items={filteredItems} />;
}

// For simple calculations, memoization may not be needed:
function FilteredList({ items, filter }) {
  const filteredItems = items.filter(i => i.category === filter);
  return <List items={filteredItems} />;
}
```

**Agent behavior**
- If a value can be computed from props or other state, don't store it in state.
- Flag `useState` + `useEffect` patterns that sync derived values.
- Prefer computing during render with optional `useMemo` for expensive calculations.
- When reviewing, ask: "Can this state be derived from existing props/state?"

---

## Quick Detection Checklist

| Pattern | Rule | Action |
|---------|------|--------|
| `.push()`, `.splice()` on state | R5 | Use spread/map |
| Context with frequent updates | R11 | Split context |
| `useState` + `useEffect` for derived value | R14 | Compute in render |
